<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ü•ö –ü–∏—Å–∞–Ω–∫–∞ –Ω–∞ –¥–æ–ª–æ–Ω—ñ üé®</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: 'Comic Neue', 'Comic Sans MS', cursive, sans-serif;
            color: white;
        }
        
        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #video { z-index: 1; display: none; }
        #canvas { z-index: 2; display: none; }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            min-width: 120px;
        }
        
        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .control-btn.off {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }
        
        .youtube-btn {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #FFD700;
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 1.2em;
            z-index: 99;
            text-align: center;
            border: 2px solid #FFD700;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
        }
        
        #eggInfo {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #ffffff;
            padding: 15px;
            border-radius: 15px;
            font-size: 0.9em;
            z-index: 98;
            text-align: center;
            border: 2px solid #FF69B4;
            display: none;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
        <div style="font-size: 1.5em; margin-bottom: 10px;" class="pulse">ü•ö –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ü–∏—Å–∞–Ω–∫–∏...</div>
        <p style="margin-top: 20px; color: rgba(255,255,255,0.9);">–ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</p>
    </div>

    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
    
    <div id="status">üëã –ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</div>
    <div id="eggInfo">üé® –ü–∏—Å–∞–Ω–∫–∞ –∑'—è–≤–∏—Ç—å—Å—è –Ω–∞ –≤–∞—à—ñ–π –¥–æ–ª–æ–Ω—ñ!</div>

    <div class="controls">
        <button id="sound-btn" class="control-btn">üîä –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫</button>
        <button id="next-btn" class="control-btn">üé® –ù–∞—Å—Ç—É–ø–Ω–∞ –ø–∏—Å–∞–Ω–∫–∞</button>
        <a href="https://www.youtube.com/playlist?list=PL6UDFwT9TzFw5K8Tzu_OgsDz7vV3N9eY-" target="_blank" class="control-btn youtube-btn">üì∫ SmartLessa</a>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        const CONFIG = {
            HAND_SMOOTHING: 0.7,
            EGG_SCALE: 0.2,
            EGG_HEIGHT_OFFSET: 0.3,
            ROTATION_SPEED: 0.3,
            DEBUG_MODE: true
        };

        const state = {
            landmarks: null,
            isHandVisible: false,
            handFrames: 0,
            audioContext: null,
            animationId: null,
            pisankaTextures: [],
            currentTextureIndex: 0,
            egg: null,
            eggGroup: null,
            isSoundOn: false,
            textureUrls: [
                'pisanka.jpg',
                'pisanka-1.jpg',
                'pisanka-2.jpg', 
                'pisanka-3.jpg',
                'pisanka-4.jpg',
                'pisanka-5.jpg'
            ]
        };

        const elements = {
            video: document.getElementById('video'),
            canvas: document.getElementById('canvas'),
            loading: document.getElementById('loading'),
            status: document.getElementById('status'),
            eggInfo: document.getElementById('eggInfo'),
            soundBtn: document.getElementById('sound-btn'),
            nextBtn: document.getElementById('next-btn')
        };

        let scene, camera, renderer;
        let handLandmarker;
        let bgMusic = new Audio('bg-music.mp3');
        bgMusic.loop = true;

        class PisankaARApp {
            constructor() {
                this.init();
            }

            async init() {
                try {
                    await this.setupCamera();
                    await this.initThreeJS();
                    await this.initHandTracking();
                    this.setupEventListeners();
                    this.hideLoading();
                    this.startAnimation();
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:', error);
                    this.showError('–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É —Ç–∞ –¥–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä—ñ');
                }
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    elements.video.srcObject = stream;
                    await new Promise(resolve => {
                        elements.video.onloadedmetadata = () => {
                            elements.video.play();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä—ñ');
                }
            }

            async initThreeJS() {
                scene = new THREE.Scene();
                scene.background = null;
                
                camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 0, 5);
                
                renderer = new THREE.WebGLRenderer({
                    canvas: elements.canvas,
                    alpha: true,
                    antialias: true,
                    premultipliedAlpha: false
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x000000, 0);
                
                // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(5, 10, 7);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                await this.createPisanka();
            }

            async createPisanka() {
                state.eggGroup = new THREE.Group();
                scene.add(state.eggGroup);
                
                // –°—Ç–≤–æ—Ä—é—î–º–æ —è–π—Ü–µ–ø–æ–¥—ñ–±–Ω—É –≥–µ–æ–º–µ—Ç—Ä—ñ—é
                const eggGeometry = this.createEggGeometry();
                
                // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ —Ç–µ–∫—Å—Ç—É—Ä–∏
                await this.loadTextures();
                
                // –°—Ç–≤–æ—Ä—é—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π –º–∞—Ç–µ—Ä—ñ–∞–ª –¥–ª—è –ø–∏—Å–∞–Ω–∫–∏
                const eggMaterial = new THREE.MeshStandardMaterial({
                    map: state.pisankaTextures[0],
                    color: 0xffffff,
                    roughness: 0.3,
                    metalness: 0.1,
                    transparent: false,
                    opacity: 1,
                    side: THREE.DoubleSide,
                    alphaTest: 0.1
                });
                
                // –°—Ç–≤–æ—Ä—é—î–º–æ –º–µ—à –ø–∏—Å–∞–Ω–∫–∏
                state.egg = new THREE.Mesh(eggGeometry, eggMaterial);
                state.egg.scale.set(CONFIG.EGG_SCALE, CONFIG.EGG_SCALE, CONFIG.EGG_SCALE);
                state.egg.castShadow = true;
                state.egg.receiveShadow = true;
                state.eggGroup.add(state.egg);
                
                // –î–æ–¥–∞—î–º–æ –ø—ñ–¥—Å–≤—ñ—á—É–≤–∞–Ω–Ω—è –Ω–∞–≤–∫–æ–ª–æ –ø–∏—Å–∞–Ω–∫–∏
                this.createEggGlow();
                
                // –î–æ–¥–∞—î–º–æ –ø—ñ–¥—Å—Ç–∞–≤–∫—É
                this.createStand();
                
                state.eggGroup.visible = false;
                
                console.log('‚úÖ –ü–∏—Å–∞–Ω–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–∞');
            }

            createEggGeometry() {
                const segments = 32;
                const geometry = new THREE.SphereGeometry(1, segments, segments);
                
                // –†–æ–±–∏–º–æ —Ñ–æ—Ä–º—É –±—ñ–ª—å—à —è–π—Ü–µ–ø–æ–¥—ñ–±–Ω–æ—é
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è
                    let scaleY = 1.4;
                    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è
                    let scaleX = 0.7;
                    let scaleZ = 0.7;
                    
                    // –†–æ–±–∏–º–æ –≤–µ—Ä—Ö –æ–∫—Ä—É–≥–ª—ñ—à–∏–º
                    if (y > 0.5) {
                        scaleY = 1.6;
                    }
                    
                    positions.setX(i, x * scaleX);
                    positions.setY(i, y * scaleY);
                    positions.setZ(i, z * scaleZ);
                }
                
                geometry.computeVertexNormals();
                return geometry;
            }

            async loadTextures() {
                state.pisankaTextures = [];
                const loader = new THREE.TextureLoader();
                
                for (const url of state.textureUrls) {
                    try {
                        const texture = await new Promise((resolve, reject) => {
                            loader.load(
                                url,
                                (tex) => {
                                    tex.wrapS = THREE.RepeatWrapping;
                                    tex.wrapT = THREE.RepeatWrapping;
                                    tex.colorSpace = THREE.SRGBColorSpace;
                                    tex.flipY = false;
                                    console.log(`‚úÖ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ: ${url}`);
                                    resolve(tex);
                                },
                                undefined,
                                (err) => {
                                    console.warn(`‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: ${url}`);
                                    reject(err);
                                }
                            );
                        });
                        state.pisankaTextures.push(texture);
                    } catch (error) {
                        console.log(`–°—Ç–≤–æ—Ä—é—é –∑–∞–ø–∞—Å–Ω—É —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è: ${url}`);
                        const fallbackTexture = this.createFallbackTexture();
                        state.pisankaTextures.push(fallbackTexture);
                    }
                }
                
                if (state.pisankaTextures.length === 0) {
                    console.log('–°—Ç–≤–æ—Ä—é—é –æ—Å—Ç–∞–Ω–Ω—é –∑–∞–ø–∞—Å–Ω—É —Ç–µ–∫—Å—Ç—É—Ä—É');
                    state.pisankaTextures.push(this.createFallbackTexture());
                }
                
                console.log(`–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ ${state.pisankaTextures.length} —Ç–µ–∫—Å—Ç—É—Ä`);
            }

            createFallbackTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                
                // –ó–∞–ø–æ–≤–Ω—é—î–º–æ –±—ñ–ª–∏–º —Ñ–æ–Ω–æ–º
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, 1024, 1024);
                
                // –ú–∞–ª—é—î–º–æ —è—Å–∫—Ä–∞–≤–∏–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π –≤—ñ–∑–µ—Ä—É–Ω–æ–∫
                const colors = ['#0057B7', '#FFD700', '#FF0000', '#00FF00', '#FF00FF'];
                
                // –í–µ–ª–∏–∫–∏–π —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∏–π –∫—Ä—É–≥
                ctx.fillStyle = colors[0];
                ctx.beginPath();
                ctx.arc(512, 512, 400, 0, Math.PI * 2);
                ctx.fill();
                
                // –î—Ä—É–≥–∏–π –∫—Ä—É–≥
                ctx.fillStyle = colors[1];
                ctx.beginPath();
                ctx.arc(512, 512, 350, 0, Math.PI * 2);
                ctx.fill();
                
                // –•—Ä–µ—Å—Ç
                ctx.fillStyle = colors[2];
                ctx.fillRect(462, 212, 100, 600);
                ctx.fillRect(212, 462, 600, 100);
                
                // –¢–µ–∫—Å—Ç—É—Ä–Ω—ñ —Ç–æ—á–∫–∏
                ctx.fillStyle = colors[3];
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * 1024;
                    const y = Math.random() * 1024;
                    const radius = Math.random() * 30 + 10;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // –ï–º–±–ª–µ–º–∞ —è–π—Ü—è
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 200px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ü•ö', 512, 512);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.flipY = false;
                return texture;
            }

            createEggGlow() {
                const glowGeometry = new THREE.SphereGeometry(1.05, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.scale.set(0.65, 1.08, 0.65);
                state.eggGroup.add(glow);
            }

            createStand() {
                const standGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.08, 16);
                const standMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const stand = new THREE.Mesh(standGeometry, standMaterial);
                stand.position.y = -0.15;
                stand.castShadow = true;
                stand.receiveShadow = true;
                state.eggGroup.add(stand);
                
                // –î–æ–¥–∞—î–º–æ —Ç—Ä–æ—à–∫–∏ –¥–µ—Ç–∞–ª–µ–π –¥–æ –ø—ñ–¥—Å—Ç–∞–≤–∫–∏
                const ringGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 16);
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.5
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = -0.11;
                ring.rotation.x = Math.PI / 2;
                state.eggGroup.add(ring);
            }

            async initHandTracking() {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
            }

            setupEventListeners() {
                elements.soundBtn.addEventListener('click', () => this.toggleSound());
                elements.nextBtn.addEventListener('click', () => this.nextTexture());
                window.addEventListener('resize', () => this.onWindowResize());
                
                // –û–±—Ä–æ–±–∫–∞ —Ç–∞—á –∂–µ—Å—Ç–æ–≤ –Ω–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö
                let touchStartX = 0;
                let touchStartY = 0;
                let isTouching = false;
                
                elements.canvas.addEventListener('touchstart', (e) => {
                    if (!state.eggGroup.visible) return;
                    e.preventDefault();
                    isTouching = true;
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                elements.canvas.addEventListener('touchmove', (e) => {
                    if (!isTouching || !state.eggGroup.visible) return;
                    e.preventDefault();
                    
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    const deltaX = touchX - touchStartX;
                    const deltaY = touchY - touchStartY;
                    
                    state.eggGroup.rotation.y += deltaX * 0.01;
                    state.eggGroup.rotation.x += deltaY * 0.01;
                    
                    touchStartX = touchX;
                    touchStartY = touchY;
                });
                
                elements.canvas.addEventListener('touchend', () => {
                    isTouching = false;
                });
                
                // –û–±—Ä–æ–±–∫–∞ —Å–∫—Ä–æ–ª—É –¥–ª—è –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è
                elements.canvas.addEventListener('wheel', (e) => {
                    if (!state.eggGroup.visible) return;
                    e.preventDefault();
                    
                    let scale = state.eggGroup.scale.x / CONFIG.EGG_SCALE;
                    scale += e.deltaY * -0.001;
                    scale = Math.max(0.3, Math.min(3, scale));
                    
                    state.eggGroup.scale.setScalar(scale * CONFIG.EGG_SCALE);
                });
            }

            toggleSound() {
                if (state.isSoundOn) {
                    bgMusic.pause();
                    elements.soundBtn.classList.add('off');
                    elements.soundBtn.textContent = 'üîá –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫';
                } else {
                    bgMusic.volume = 0.5;
                    bgMusic.play().catch(e => {
                        console.log("–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –º—É–∑–∏–∫–∏:", e);
                        elements.soundBtn.textContent = 'üîá –ü–æ–º–∏–ª–∫–∞ –∑–≤—É–∫—É';
                    });
                    elements.soundBtn.classList.remove('off');
                    elements.soundBtn.textContent = 'üîä –í–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫';
                }
                state.isSoundOn = !state.isSoundOn;
            }

            nextTexture() {
                if (!state.egg || state.pisankaTextures.length === 0) {
                    console.log('–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–µ–∫—Å—Ç—É—Ä');
                    return;
                }
                
                state.currentTextureIndex = (state.currentTextureIndex + 1) % state.pisankaTextures.length;
                state.egg.material.map = state.pisankaTextures[state.currentTextureIndex];
                state.egg.material.needsUpdate = true;
                
                elements.eggInfo.innerHTML = `üé® –ü–∏—Å–∞–Ω–∫–∞ ${state.currentTextureIndex + 1}/${state.pisankaTextures.length}`;
                elements.eggInfo.style.display = 'block';
                
                setTimeout(() => {
                    elements.eggInfo.style.display = 'none';
                }, 1500);
            }

            startAnimation() {
                const animate = () => {
                    this.update();
                    this.render();
                    state.animationId = requestAnimationFrame(animate.bind(this));
                };
                animate();
            }

            update() {
                this.detectHand();
                
                if (state.landmarks && state.isHandVisible) {
                    this.updateEggPosition();
                    
                    if (!state.eggGroup.visible) {
                        state.eggGroup.visible = true;
                        elements.status.style.display = 'none';
                        elements.eggInfo.style.display = 'block';
                        elements.eggInfo.innerHTML = 'ü•ö –ü–∏—Å–∞–Ω–∫–∞ –Ω–∞ –≤–∞—à—ñ–π –¥–æ–ª–æ–Ω—ñ!';
                        
                        setTimeout(() => {
                            elements.eggInfo.style.display = 'none';
                        }, 2000);
                    }
                    
                    // –ü–ª–∞–≤–Ω–µ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è
                    state.eggGroup.rotation.y += CONFIG.ROTATION_SPEED * 0.01;
                    
                    // –õ–µ–≥–∫–∞ –ø—É–ª—å—Å–∞—Ü—ñ—è
                    const pulse = Math.sin(Date.now() * 0.002) * 0.02 + 1;
                    state.eggGroup.scale.setScalar(pulse * CONFIG.EGG_SCALE);
                    
                } else {
                    if (state.eggGroup.visible) {
                        state.eggGroup.visible = false;
                        elements.status.style.display = 'block';
                        elements.eggInfo.style.display = 'none';
                    }
                    
                    if (state.handFrames > 30) {
                        elements.status.textContent = 'üëã –ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ';
                    }
                }
            }

            detectHand() {
                if (!handLandmarker || elements.video.readyState < 2) return;
                
                try {
                    const results = handLandmarker.detectForVideo(elements.video, performance.now());
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        state.landmarks = results.landmarks[0];
                        state.isHandVisible = true;
                        state.handFrames = 0;
                    } else {
                        state.landmarks = null;
                        state.isHandVisible = false;
                        state.handFrames++;
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ä—É–∫–∏:', error);
                }
            }

            updateEggPosition() {
                if (!state.landmarks) return;
                
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç–æ—á–∫—É —Ü–µ–Ω—Ç—Ä—É –¥–æ–ª–æ–Ω—ñ (–ø–∞–ª—å—Ü–µ–≤–∞ –æ—Å–Ω–æ–≤–∞)
                const centerX = state.landmarks[9].x;
                const centerY = state.landmarks[9].y;
                const centerZ = state.landmarks[9].z || 0;
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                const x = (centerX - 0.5) * 8;
                const y = (0.5 - centerY) * 6 + CONFIG.EGG_HEIGHT_OFFSET;
                const z = (centerZ - 0.5) * 3;
                
                if (state.eggGroup) {
                    // –ü–ª–∞–≤–Ω–∞ —ñ–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è
                    state.eggGroup.position.x += (x - state.eggGroup.position.x) * CONFIG.HAND_SMOOTHING;
                    state.eggGroup.position.y += (y - state.eggGroup.position.y) * CONFIG.HAND_SMOOTHING;
                    state.eggGroup.position.z += (z - state.eggGroup.position.z) * CONFIG.HAND_SMOOTHING;
                    
                    // –û—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è –¥–æ –∫–∞–º–µ—Ä–∏
                    state.eggGroup.lookAt(camera.position.x, camera.position.y, camera.position.z);
                }
            }

            render() {
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }

            onWindowResize() {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            hideLoading() {
                elements.loading.style.display = 'none';
                elements.video.style.display = 'block';
                elements.canvas.style.display = 'block';
                elements.status.style.display = 'block';
            }

            showError(message) {
                elements.loading.innerHTML = `
                    <div style="color: #ff6b6b; font-size: 28px; margin-bottom: 20px;">üòï</div>
                    <div style="font-size: 18px; margin-bottom: 20px;">${message}</div>
                    <button onclick="location.reload()" style="padding: 14px 28px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px;">
                        –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
                    </button>
                `;
            }

            cleanup() {
                if (state.animationId) cancelAnimationFrame(state.animationId);
                if (elements.video.srcObject) {
                    elements.video.srcObject.getTracks().forEach(track => track.stop());
                }
                if (handLandmarker) handLandmarker.close();
                bgMusic.pause();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            const app = new PisankaARApp();
            window.addEventListener('beforeunload', () => app.cleanup());
        });
    </script>
</body>
</html>
