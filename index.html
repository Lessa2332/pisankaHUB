<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ü•ö –ü–∏—Å–∞–Ω–∫–∞ –Ω–∞ –¥–æ–ª–æ–Ω—ñ üé®</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #8A2BE2 0%, #4B0082 100%);
      overflow: hidden;
      font-family: 'Comic Neue', 'Comic Sans MS', cursive, sans-serif;
      color: white;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #8A2BE2 0%, #4B0082 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
      text-align: center;
      padding: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    #eggText {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 20px;
      font-size: 1.3em;
      font-weight: bold;
      z-index: 85;
      text-align: center;
      border: 2px solid #FFD700;
      display: none;
      max-width: 90%;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    #handIndicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 20px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 99;
      font-size: 17px;
      font-weight: bold;
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    #eggStatus {
      position: fixed;
      top: 85px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 20px;
      font-size: 17px;
      z-index: 100;
      display: none;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }

    .controls {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      gap: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }

    .control-btn {
      padding: 12px 20px;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      font-family: inherit;
      font-size: 1em;
      font-weight: bold;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      min-width: 120px;
    }

    .control-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .control-btn.off {
      background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
    }

    .youtube-btn {
      background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div style="font-size: 1.5em; margin-bottom: 10px;">ü•ö –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ü–∏—Å–∞–Ω–∫–∏...</div>
    <p style="margin-top: 20px; color: rgba(255,255,255,0.9);">–ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="eggText">ü•ö –ü–∏—Å–∞–Ω–∫–∞ –Ω–∞ –≤–∞—à—ñ–π –¥–æ–ª–æ–Ω—ñ! üé®</div>
  <div id="eggStatus">‚ú® –ü–∏—Å–∞–Ω–∫–∞ –æ–±–µ—Ä—Ç–∞—î—Ç—å—Å—è</div>
  <div id="handIndicator">üëã –ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</div>

  <div class="controls">
    <button id="sound-btn" class="control-btn">üîä –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫</button>
    <button id="next-btn" class="control-btn">üé® –ù–∞—Å—Ç—É–ø–Ω–∞ –ø–∏—Å–∞–Ω–∫–∞</button>
    <a href="https://www.youtube.com/playlist?list=PL6UDFwT9TzFw5K8Tzu_OgsDz7vV3N9eY-" target="_blank" class="control-btn youtube-btn">üì∫ SmartLessa</a>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    const CONFIG = {
      SMOOTHING_FACTOR: 0.6,
      HAND_NOT_DETECTED_THRESHOLD: 30,
      EGG_SCALE: 0.15,
      EGG_HEIGHT_OFFSET: 0.3,
      ROTATION_SPEED: 1.0,
      DEBUG_MODE: false,
      textureUrls: [
        'pisanka.jpg',
        'pisanka-1.jpg',
        'pisanka-2.jpg', 
        'pisanka-3.jpg',
        'pisanka-4.jpg',
        'pisanka-5.jpg'
      ]
    };

    // –°—Ç–∞–Ω –¥–æ–¥–∞—Ç–∫—É
    const state = {
      landmarks: null,
      isHandVisible: false,
      handFrames: 0,
      audioContext: null,
      analyser: null,
      animationId: null,
      time: 0,
      pisankaTextures: [],
      currentTextureIndex: 0,
      egg: null,
      eggGroup: null,
      isSoundOn: false
    };

    // DOM –µ–ª–µ–º–µ–Ω—Ç–∏
    const elements = {
      video: document.getElementById('video'),
      canvas: document.getElementById('canvas'),
      loading: document.getElementById('loading'),
      eggText: document.getElementById('eggText'),
      eggStatus: document.getElementById('eggStatus'),
      handIndicator: document.getElementById('handIndicator'),
      soundBtn: document.getElementById('sound-btn'),
      nextBtn: document.getElementById('next-btn')
    };

    // Three.js –∑–º—ñ–Ω–Ω—ñ
    let scene, camera, renderer;
    let handLandmarker;
    let bgMusic = new Audio('bg-music.mp3');
    bgMusic.loop = true;

    class PisankaARApp {
      constructor() {
        this.init();
      }

      async init() {
        try {
          await this.setupCamera();
          await this.initThreeJS();
          await this.initHandTracking();
          this.setupEventListeners();
          this.hideLoading();
          this.startAnimation();
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:', error);
          this.showError('–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É —Ç–∞ –¥–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
          elements.video.srcObject = stream;
          await new Promise(resolve => {
            elements.video.onloadedmetadata = () => {
              elements.video.play();
              resolve();
            };
          });
        } catch (error) {
          throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async initThreeJS() {
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Å—Ü–µ–Ω—É
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x8A2BE2, 5, 15);
        
        // –ö–∞–º–µ—Ä–∞
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.1, 
          1000
        );
        camera.position.set(0, 0, 5);
        
        // –†–µ–Ω–¥–µ—Ä–µ—Ä
        renderer = new THREE.WebGLRenderer({
          canvas: elements.canvas,
          alpha: true,
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ —Ç–µ–∫—Å—Ç—É—Ä–∏ –ø–∏—Å–∞–Ω–æ–∫
        await this.loadPisankaTextures();
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –ø–∏—Å–∞–Ω–∫—É
        this.createPisanka();
      }

      async loadPisankaTextures() {
        state.pisankaTextures = [];
        const loader = new THREE.TextureLoader();
        
        for (const url of CONFIG.textureUrls) {
          try {
            const texture = await new Promise((resolve, reject) => {
              loader.load(
                url,
                (tex) => {
                  tex.colorSpace = THREE.SRGBColorSpace;
                  resolve(tex);
                },
                undefined,
                (err) => {
                  console.warn(`‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ç–µ–∫—Å—Ç—É—Ä—É: ${url}`);
                  reject(err);
                }
              );
            });
            state.pisankaTextures.push(texture);
            console.log(`‚úÖ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ: ${url}`);
          } catch (error) {
            console.log(`–°—Ç–≤–æ—Ä—é—é –∑–∞–ø–∞—Å–Ω—É —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è: ${url}`);
            const fallbackTexture = this.createFallbackTexture();
            state.pisankaTextures.push(fallbackTexture);
          }
        }
        
        if (state.pisankaTextures.length === 0) {
          console.log('–°—Ç–≤–æ—Ä—é—é –∑–∞–ø–∞—Å–Ω—É —Ç–µ–∫—Å—Ç—É—Ä—É');
          state.pisankaTextures.push(this.createFallbackTexture());
        }
        
        console.log(`üìä –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ ${state.pisankaTextures.length} —Ç–µ–∫—Å—Ç—É—Ä`);
      }

      createFallbackTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        // –ë—ñ–ª–∏–π —Ñ–æ–Ω
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, 1024, 1024);
        
        // –£–∫—Ä–∞—ó–Ω—Å—å–∫—ñ –∫–æ–ª—å–æ—Ä–∏
        ctx.fillStyle = '#0057B7';
        ctx.beginPath();
        ctx.arc(512, 512, 400, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(512, 512, 350, 0, Math.PI * 2);
        ctx.fill();
        
        // –í—ñ–∑–µ—Ä—É–Ω–∫–∏ –ø–∏—Å–∞–Ω–∫–∏
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 20;
        
        // –•—Ä–µ—Å—Ç
        ctx.beginPath();
        ctx.moveTo(512, 112);
        ctx.lineTo(512, 912);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(112, 512);
        ctx.lineTo(912, 512);
        ctx.stroke();
        
        // –ö–æ–ª–∞
        ctx.strokeStyle = '#00FF00';
        ctx.beginPath();
        ctx.arc(512, 512, 300, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(512, 512, 200, 0, Math.PI * 2);
        ctx.stroke();
        
        // –¢–µ–∫—Å—Ç
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 150px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ü•ö', 512, 512);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      }

      createPisanka() {
        // –ì—Ä—É–ø–∞ –¥–ª—è –≤—Å—ñ—î—ó –ø–∏—Å–∞–Ω–∫–∏
        state.eggGroup = new THREE.Group();
        state.eggGroup.visible = false;
        scene.add(state.eggGroup);
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ —è–π—Ü–µ–ø–æ–¥—ñ–±–Ω—É —Ñ–æ—Ä–º—É
        const eggGeometry = new THREE.SphereGeometry(1, 32, 32);
        
        // –î–µ—Ñ–æ—Ä–º—É—î–º–æ —Å—Ñ–µ—Ä—É –≤ —è–π—Ü–µ
        const positions = eggGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);
          
          // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–µ —Ä–æ–∑—Ç—è–≥–Ω–µ–Ω–Ω—è
          let newY = y * 1.4;
          // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–µ —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è
          let newX = x * 0.7;
          let newZ = z * 0.7;
          
          positions.setX(i, newX);
          positions.setY(i, newY);
          positions.setZ(i, newZ);
        }
        
        eggGeometry.computeVertexNormals();
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –º–∞—Ç–µ—Ä—ñ–∞–ª –¥–ª—è –ø–∏—Å–∞–Ω–∫–∏
        const eggMaterial = new THREE.MeshStandardMaterial({
          map: state.pisankaTextures[0],
          color: 0xffffff,
          roughness: 0.3,
          metalness: 0.1,
          side: THREE.DoubleSide
        });
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –º–µ—à –ø–∏—Å–∞–Ω–∫–∏
        state.egg = new THREE.Mesh(eggGeometry, eggMaterial);
        state.egg.scale.set(CONFIG.EGG_SCALE, CONFIG.EGG_SCALE, CONFIG.EGG_SCALE);
        state.eggGroup.add(state.egg);
        
        // –î–æ–¥–∞—î–º–æ –µ—Ñ–µ–∫—Ç —Å–≤—ñ—Ç—ñ–Ω–Ω—è
        const glowGeometry = new THREE.SphereGeometry(1.05, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xFFD700,
          transparent: true,
          opacity: 0.1,
          side: THREE.BackSide
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.scale.set(0.71, 1.45, 0.71);
        state.eggGroup.add(glow);
        
        // –î–æ–¥–∞—î–º–æ –ø—Ä–æ—Å—Ç—É –ø—ñ–¥—Å—Ç–∞–≤–∫—É
        const standGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.05, 8);
        const standMaterial = new THREE.MeshStandardMaterial({
          color: 0x8B4513,
          roughness: 0.8
        });
        
        const stand = new THREE.Mesh(standGeometry, standMaterial);
        stand.position.y = -0.18;
        state.eggGroup.add(stand);
        
        console.log('‚úÖ –ü–∏—Å–∞–Ω–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–∞');
      }

      async initHandTracking() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      setupEventListeners() {
        elements.soundBtn.addEventListener('click', () => this.toggleSound());
        elements.nextBtn.addEventListener('click', () => this.nextTexture());
        window.addEventListener('resize', () => this.onWindowResize());
        
        // –û–±–µ—Ä—Ç–∞–Ω–Ω—è –ø–∏—Å–∞–Ω–∫–∏ –º–∏—à–µ—é
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let scale = 1;
        
        elements.canvas.addEventListener('mousedown', (e) => {
          if (!state.eggGroup.visible) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
          elements.canvas.style.cursor = 'grabbing';
        });
        
        elements.canvas.addEventListener('mousemove', (e) => {
          if (!isDragging || !state.eggGroup.visible) return;
          
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;
          
          state.eggGroup.rotation.y += deltaX * 0.01;
          state.eggGroup.rotation.x += deltaY * 0.01;
          
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        elements.canvas.addEventListener('mouseup', () => {
          isDragging = false;
          elements.canvas.style.cursor = 'default';
        });
        
        elements.canvas.addEventListener('wheel', (e) => {
          if (!state.eggGroup.visible) return;
          e.preventDefault();
          
          scale += e.deltaY * -0.001;
          scale = Math.max(0.3, Math.min(3, scale));
          
          state.eggGroup.scale.setScalar(scale * CONFIG.EGG_SCALE);
        });
        
        // –¢–∞—á –∂–µ—Å—Ç–∏ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouching = false;
        
        elements.canvas.addEventListener('touchstart', (e) => {
          if (!state.eggGroup.visible) return;
          e.preventDefault();
          isTouching = true;
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        });
        
        elements.canvas.addEventListener('touchmove', (e) => {
          if (!isTouching || !state.eggGroup.visible) return;
          e.preventDefault();
          
          const touchX = e.touches[0].clientX;
          const touchY = e.touches[0].clientY;
          
          const deltaX = touchX - touchStartX;
          const deltaY = touchY - touchStartY;
          
          state.eggGroup.rotation.y += deltaX * 0.01;
          state.eggGroup.rotation.x += deltaY * 0.01;
          
          touchStartX = touchX;
          touchStartY = touchY;
        });
        
        elements.canvas.addEventListener('touchend', () => {
          isTouching = false;
        });
      }

      toggleSound() {
        if (state.isSoundOn) {
          bgMusic.pause();
          elements.soundBtn.classList.add('off');
          elements.soundBtn.textContent = 'üîá –£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫';
        } else {
          bgMusic.volume = 0.5;
          bgMusic.play().catch(e => {
            console.log("–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –º—É–∑–∏–∫–∏:", e);
            elements.soundBtn.textContent = 'üîá –ü–æ–º–∏–ª–∫–∞ –∑–≤—É–∫—É';
          });
          elements.soundBtn.classList.remove('off');
          elements.soundBtn.textContent = 'üîä –í–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫';
        }
        state.isSoundOn = !state.isSoundOn;
      }

      nextTexture() {
        if (!state.egg || state.pisankaTextures.length === 0) {
          console.log('–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ç–µ–∫—Å—Ç—É—Ä');
          return;
        }
        
        state.currentTextureIndex = (state.currentTextureIndex + 1) % state.pisankaTextures.length;
        state.egg.material.map = state.pisankaTextures[state.currentTextureIndex];
        state.egg.material.needsUpdate = true;
        
        elements.eggStatus.textContent = `üé® –ü–∏—Å–∞–Ω–∫–∞ ${state.currentTextureIndex + 1}/${state.pisankaTextures.length}`;
        elements.eggStatus.style.display = 'block';
        
        setTimeout(() => {
          elements.eggStatus.textContent = '‚ú® –ü–∏—Å–∞–Ω–∫–∞ –æ–±–µ—Ä—Ç–∞—î—Ç—å—Å—è';
        }, 1500);
      }

      startAnimation() {
        const animate = () => {
          state.time += 0.016;
          this.update();
          this.render();
          state.animationId = requestAnimationFrame(animate);
        };
        animate();
      }

      update() {
        this.detectHand();
        
        if (state.landmarks && state.isHandVisible) {
          this.updatePosition();
          
          if (!state.eggGroup.visible) {
            state.eggGroup.visible = true;
            elements.eggText.style.display = 'block';
            elements.eggStatus.style.display = 'block';
            elements.handIndicator.style.display = 'none';
          }
        } else {
          if (state.eggGroup.visible) {
            state.eggGroup.visible = false;
            elements.eggText.style.display = 'none';
            elements.eggStatus.style.display = 'none';
          }
          
          if (state.handFrames > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
            elements.handIndicator.style.display = 'flex';
          }
        }
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è –ø–∏—Å–∞–Ω–∫–∏
        if (state.eggGroup && state.eggGroup.visible) {
          state.eggGroup.rotation.y += CONFIG.ROTATION_SPEED * 0.01;
        }
      }

      detectHand() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        
        try {
          const results = handLandmarker.detectForVideo(elements.video, performance.now());
          
          if (results.landmarks && results.landmarks.length > 0) {
            state.landmarks = results.landmarks[0];
            state.isHandVisible = true;
            state.handFrames = 0;
          } else {
            state.landmarks = null;
            state.isHandVisible = false;
            state.handFrames++;
          }
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ä—É–∫–∏:', error);
        }
      }

      updatePosition() {
        if (!state.landmarks) return;
        
        // –¶–µ–Ω—Ç—Ä –¥–æ–ª–æ–Ω—ñ
        const points = [0, 5, 9, 13, 17];
        let centerX = 0, centerY = 0;
        for (const idx of points) {
          centerX += state.landmarks[idx].x;
          centerY += state.landmarks[idx].y;
        }
        centerX /= points.length;
        centerY /= points.length;
        
        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        const x = (centerX - 0.5) * 8;
        const y = (0.5 - centerY) * 6 + CONFIG.EGG_HEIGHT_OFFSET;
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ –ø–∏—Å–∞–Ω–∫—É
        if (state.eggGroup) {
          state.eggGroup.position.x += (x - state.eggGroup.position.x) * CONFIG.SMOOTHING_FACTOR;
          state.eggGroup.position.y += (y - state.eggGroup.position.y) * CONFIG.SMOOTHING_FACTOR;
          state.eggGroup.lookAt(camera.position);
        }
      }

      render() {
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      onWindowResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      hideLoading() {
        elements.loading.style.display = 'none';
        elements.video.style.display = 'block';
        elements.canvas.style.display = 'block';
        elements.handIndicator.style.display = 'flex';
      }

      showError(message) {
        elements.loading.innerHTML = `
          <div style="color: #ff6b6b; font-size: 28px; margin-bottom: 20px;">üòï</div>
          <div style="font-size: 18px; margin-bottom: 20px;">${message}</div>
          <button onclick="location.reload()" style="padding: 14px 28px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px;">
            –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
          </button>
        `;
      }

      cleanup() {
        if (state.animationId) cancelAnimationFrame(state.animationId);
        if (elements.video.srcObject) {
          elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        if (handLandmarker) handLandmarker.close();
        bgMusic.pause();
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      const app = new PisankaARApp();
      window.addEventListener('beforeunload', () => app.cleanup());
    });
  </script>
</body>
</html>
